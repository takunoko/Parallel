並列計算とか扱ってみた

## 環境
学校 OpenMP, Intel MPI
自宅 OpenMP, OpenMPI

## 構成
#### MPI/
MPI関連(メモリ非共有)
複数のPCをつないだり、プロセスとして分割する。
- MPI
	-	mpi_test
		-	mpiのランクを表示するだけのプログラム
		-	実行の際はsrun(Phi)やmiprun(学校)を使う
	- MPICH2
		- myname
			- 実行しているランクを表示する。(mpi_testと変わらない…)
		- hostfile
			- mpiで複数のPCを利用する際のホスト名を記録しておく。

#### OpenMP/
OpenMP関連(メモリ共有)
簡単に言えば、同じCPU,同じPC内で完結する。

- OpenMP
	- test1
		- OpenMPのバージョン確認
	- test2
		- 適当にforの並列化
	- test3
		- 各スレッドで1000ループ
		- それの足し合わせとか。スコープみたいな話
	- test4
		- システムの要件
		- 使えるスレッドの数とか
	- test_loop
		- sum += i;を大量にやる
		- 並列化とそうでないものの違いを見る
		- test_loop.hが必要
	- test_s_loop
		- sum += i;のシングルスレッド版
		- test_loop.hが必要
	- my_test1
		- 乱数がプロセスごとに別に生成されるかの確認
		- 無事に別々に生成された

#### DP/
授業で用いたDragonPoleのプログラム
内容としては、組み合わせ最適解を求める問題

- Xeon_dp
	- dragonpole.hを書き換えれば、多分複数のサイズに対応できるプログラム
- Xeon_dp_100_v0
	- 100bitのドラゴンポールに特化したプログラム
	- 乱数の生成はrand()を4回呼び出している
- Xeon_dp_100_v1
	- 100bitのドラゴンポールに特化したプログラム
	- 乱数の生成はSFMT(メルセンヌツイスターの改良)を用いている。
	- 速度が若干向上している
	- Makefileのオプションをいじる必要があるかも
- Xeon_dp_100_v2
	- 乱数の初期化は並列化対応したものを用いる必要がある。
	- 現在実装中
